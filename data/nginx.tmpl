{{ define "upstream" }}
        {{ $networks := .Networks }}

        upstream {{ .Upstream }} {
        {{ $server_found := "false" }}
        {{ range $container := .Containers }}

        {{ $defaultPort := (when (eq (len $container.Addresses) 1) (first $container.Addresses) (dict "Port" "80")).Port }}
        {{ $port := (coalesce $container.Env.VIRTUAL_PORT $defaultPort) }}
        {{ $address := where $container.Addresses "Port" $port | first }}

                {{ range $knownNetwork := $networks }}
                        {{ range $containerNetwork := $container.Networks }}
                                {{ if (and (ne $containerNetwork.Name "ingress") (or (eq $knownNetwork.Name $containerNetwork.Name) (eq $knownNetwork.Name "host"))) }}
        ## Can be connected with "{{ $containerNetwork.Name }}" network
                    {{ if $address }}
                        {{/* If we got the containers from swarm and this container's port is published to host, use host IP:PORT */}}
                        {{ if and $container.Node.ID $address.HostPort }}
                            {{ $server_found = "true" }}
        # {{ $container.Node.Name }}/{{ $container.Name }}
        #server {{ $container.Node.Address.IP }}:{{ $address.HostPort }};
        server {{ $container.Name }}:{{ $address.HostPort }};
                        {{/* If there is no swarm node or the port is not published on host, use container's IP:PORT */}}
                        {{ else if $containerNetwork }}
                            {{ $server_found = "true" }}
        # {{ $container.Name }}
        server {{ $container.Name }}:{{ $address.Port }};
                        {{ end }}
                    {{ else if $containerNetwork }}
        # {{ $container.Name }}
                        {{ if $containerNetwork.IP }}
                            {{ $server_found = "true" }}
        server {{ $container.Name }}:{{ $port }};
                        {{ else }}
        # /!\ No IP for this network!
                        {{ end }}
                                        {{ end }}
                                {{ else }}
        # Cannot connect to network '{{ $containerNetwork.Name }}' of this container
                                {{ end }}
                        {{ end }}
                {{ end }}
        {{ end }}

        {{ if (eq $server_found "false") }}
        # Fallback entry
        server 127.0.0.1 down;
        {{ end }}
        }
{{ end }}

server {
  listen 80 default_server;
  server_name _;
  error_log /proc/self/fd/2;
  access_log /proc/self/fd/1;
  server_tokens off;

  location /.well-known/acme-challenge/ {
    root /var/www/certbot;
  }

  location / {
    return 301 https://$host$request_uri;
  }
}

{{ $CurrentContainer := where $ "ID" .Docker.CurrentContainerID | first }}
{{ range $host, $containers := groupByMulti $ "Env.VIRTUAL_HOST" "," }}
{{ $host := trim $host }}
{{ $cert := print "/etc/letsencrypt/archive/" $host }}
{{ $is_regexp := hasPrefix "~" $host }}
{{ $sha1_upstream_name := parseBool (coalesce $.Env.SHA1_UPSTREAM_NAME "false") }}
{{ $upstream_name := when (or $is_regexp $sha1_upstream_name) (sha1 $host) $host }}
{{ template "upstream" (dict "Upstream" $upstream_name "Containers" $containers "Networks" $CurrentContainer.Networks) }}
{{ $proto := trim (or (first (groupByKeys $containers "Env.VIRTUAL_PROTO")) "http") }}

{{ if exists $cert }}
server {
  listen  80;
  add_header  Strict-Transport-Security "max-age=0;";
  server_name {{ $host }};
  return 301 https://{{ $host }}$request_uri;
}

server {
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

    server_name {{ $host }};
    proxy_buffering off;
    error_log /proc/self/fd/2;
    access_log /proc/self/fd/1;

    listen 443 ssl http2;
    client_max_body_size 55M;

    ssl_certificate /etc/letsencrypt/live/{{ $host }}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{{ $host }}/privkey.pem;

    location / {
      proxy_pass {{ trim $proto }}://{{ trim $host }};
      proxy_connect_timeout       300;
      proxy_send_timeout          300;
      proxy_read_timeout          300;
      send_timeout                300;
      proxy_set_header Host {{ $host }};
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /.well-known/acme-challenge/ {
      root /var/www/certbot;
    }
}
{{ else }}
server {
    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

    server_name {{ $host }};
    proxy_buffering off;
    error_log /proc/self/fd/2;
    access_log /proc/self/fd/1;

    listen 80;

    location / {
      proxy_pass {{ trim $proto }}://{{ trim $host }};
      proxy_connect_timeout       300;
      proxy_send_timeout          300;
      proxy_read_timeout          300;
      send_timeout                300;
      proxy_set_header Host {{ $host }};
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /.well-known/acme-challenge/ {
      root /var/www/certbot;
    }
}

{{ end }}
{{ end }}
